#if defined( EAE6320_PLATFORM_D3D )

//=================================
// HLSL
//=================================

/*
    This is an example fragment shader used to render geometry
*/

#include <Shaders/shaders.inc>

// Constant Buffers
//=================

cbuffer g_constantBuffer_perFrame : register( b0 )
{
    float g_elapsedSecondCount_systemTime;
    float g_elapsedSecondCount_simulationTime;
    // For float4 alignment
    float2 g_padding;
}

cbuffer g_constantBuffer_perMaterial : register( b1 )
{
    float4 g_color;
}

Texture2D g_color_texture : register( t0 );
SamplerState g_color_samplerState : register( s0 );

// Entry Point
//============

void main(

    // Input
    //======

    in const float4 i_position : SV_POSITION,
    in const float2 i_uv : TEXCOORD0,

    // Output
    //=======

    // Whatever color value is output from the fragment shader
    // will determine the color of the corresponding pixel on the screen
    out float4 o_color : SV_TARGET

    )
{
    // Animate the UVs
    const float animatedUV = 0.75 + sin(g_elapsedSecondCount_simulationTime) * 0.25;

    const float4 sampledColor = g_color_texture.Sample( g_color_samplerState, i_uv * animatedUV );

    const float4 animatedColor = float4(
        // R
        1.0 + (sin(g_elapsedSecondCount_simulationTime) * 0.5) - 0.5,
        // G
        1.0 + (cos(g_elapsedSecondCount_simulationTime) * 0.5) - 0.5, 
        // B
        1.0 + (sin(g_elapsedSecondCount_simulationTime) * 0.5) - 0.5,
        // Alpha
        1.0 );

    o_color = sampledColor * animatedColor;

    // EAE6320_TODO: Change the color based on time!
    // The value g_elapsedSecondCount_simulationTime constantly changes as the simulation progresses, and so by doing something like:
    //	sin( g_elapsedSecondCount_simulationTime ) or cos( g_elapsedSecondCount_simulationTime )
    // you can get a value that will oscillate between [-1,1].
    // You should change at least one "channel" so that the color animates.
    // For example, to change red ("r") you would do something kind of like:
    //		o_color.r = ? sin( g_elapsedSecondCount_simulationTime ) ?
    // You can change .r, .g, and .b (but leave .a as 1.0).
    // Remember that your final values should be [0,1], so you will have to do some math.
}

#elif defined( EAE6320_PLATFORM_GL )

//=================================
// GLSL
//=================================

/*
    This is an example fragment shader used to render geometry
*/

#include <Shaders/shaders.inc>

// Constant Buffers
//=================

layout( std140, binding = 0 ) uniform g_constantBuffer_perFrame
{
    float g_elapsedSecondCount_systemTime;
    float g_elapsedSecondCount_simulationTime;
    // For vec4 alignment
    vec2 g_padding;
};

layout( std140, binding = 1 ) uniform g_constantBuffer_perMaterial
{
    vec4 g_color;
};

layout( binding = 0 ) uniform sampler2D g_color_texture;

// Input
//======

layout( location = 0 ) in vec2 i_uv;

// Output
//=======

// Whatever color value is output from the fragment shader
// will determine the color of the corresponding pixel on the screen
out vec4 o_color;

// Entry Point
//============

void main()
{
    // Animate the UVs
    const float animatedUV = 0.75 + sin(g_elapsedSecondCount_simulationTime) * 0.25;

    vec4 sampledColor = texture2D( g_color_texture, i_uv * animatedUV );

    vec4 animatedColor = vec4(
        // R
        1.0 + (sin(g_elapsedSecondCount_simulationTime) * 0.5) - 0.5,
        // G
        1.0 + (cos(g_elapsedSecondCount_simulationTime) * 0.5) - 0.5, 
        // B
        1.0 + (sin(g_elapsedSecondCount_simulationTime) * 0.5) - 0.5,
        // Alpha
        1.0 );

    // Output solid white
    o_color = sampledColor * animatedColor;

    // EAE6320_TODO: Change the color based on time!
    // The value g_elapsedSecondCount_simulationTime constantly changes as the simulation progresses, and so by doing something like:
    //	sin( g_elapsedSecondCount_simulationTime ) or cos( g_elapsedSecondCount_simulationTime )
    // you can get a value that will oscillate between [-1,1].
    // You should change at least one "channel" so that the color animates.
    // For example, to change red ("r") you would do something kind of like:
    //		o_color.r = ? sin( g_elapsedSecondCount_simulationTime ) ?
    // You can change .r, .g, and .b (but leave .a as 1.0).
    // Remember that your final values should be [0,1], so you will have to do some math.
}

#endif